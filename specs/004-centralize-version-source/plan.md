# Implementation Plan: Centralize Java Versions Data Source

**Branch**: `004-centralize-version-source` | **Date**: 2026-02-17 | **Spec**: [spec.md](spec.md)

**Input**: Feature specification from `/specs/004-centralize-version-source/spec.md`

## Summary

Centralize Java version information to a single authoritative data source file (`src/main/resources/java_versions.txt`) that both backend and frontend will consume. Currently, the frontend has version data hardcoded in JavaScript while the backend reads from the file. This creates inconsistency risk and maintenance burden. The solution will make the backend serve version data via an API endpoint that the frontend consumes, ensuring 100% consistency.

## Technical Context

**Language/Version**: Java 21 (backend), HTML/JavaScript (frontend)
**Primary Dependencies**: Quarkus 3.x (REST, Qute templates), zip4j
**Storage**: File-based (src/main/resources/java_versions.txt)
**Testing**: JUnit 5, RestAssured
**Target Platform**: JVM (Linux/Docker deployment)
**Project Type**: Web application (backend + server-rendered frontend)
**Performance Goals**: Sub-100ms response for version list API, no impact on file upload analysis
**Constraints**: Must maintain backward compatibility with existing analysis endpoints, file must remain human-editable text format
**Scale/Scope**: 500+ version entries, <10KB file size, single-server deployment

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Constitution Compliance Review**:

✅ **I. Accuracy in Version Detection**
- Centralized source ensures consistent version identification across all interfaces
- Single source of truth eliminates divergence between frontend and backend
- File format validation ensures data quality

✅ **II. License Compliance Transparency**
- Version data source will maintain license information consistently
- Updates to license rules affect both interfaces simultaneously
- No changes to license determination logic required

✅ **III. Defensive Data Handling**
- File loading includes validation and error handling
- API endpoint will validate responses before serving to frontend
- Maintains existing file size and format validation

✅ **IV. Clear Risk Communication**
- Version categorization rules remain centralized
- Frontend and backend will display identical risk assessments
- No changes to traffic-light categorization system

✅ **V. Comprehensive Test Coverage**
- Tests will verify API endpoint returns correct version data
- Integration tests will verify frontend-backend consistency
- Existing version parsing tests remain valid

**Verdict**: ✅ ALL GATES PASS - No violations detected

## Project Structure

### Documentation (this feature)

```text
specs/004-centralize-version-source/
  plan.md              # This file
  research.md          # Phase 0 output
  data-model.md        # Phase 1 output
  quickstart.md        # Phase 1 output
  contracts/           # Phase 1 output (API contract)
  checklists/          # Quality checklists
    requirements.md
  tasks.md             # Phase 2 output (generated by /iikit-tasks)
```

### Source Code (repository root)

```text
src/
  main/
    java/
      com/github/asm0dey/
        JavaVersionService.java       # Existing - parses properties
        JavaVersionResource.java      # Existing - upload endpoint, ADD: version list API
        JavaVersionInfo.java          # Existing - version data model
        OracleLicenseChecker.java     # Existing - license logic
        VersionListService.java       # NEW - reads and serves version list
    resources/
      java_versions.txt               # Existing - THE single source of truth
      templates/
        JavaVersionResource/
          index.html                  # MODIFY - remove hardcoded list, call API
          results.html                # Existing - no changes needed
      application.properties          # Existing - no changes needed
  test/
    java/
      com/github/asm0dey/
        JavaVersionServiceTest.java   # Existing - no changes needed
        JavaVersionResourceTest.java  # MODIFY - add version list API tests
        VersionListServiceTest.java   # NEW - test version file loading
```

**Structure Decision**: Web application (Option 2) with backend providing REST API and server-rendered templates. Backend serves as single source of truth, frontend consumes via API for dynamic version data.

## Complexity Tracking

> No constitution violations requiring justification

---

*Phases 0 and 1 detailed below*

---

## Phase 0: Outline & Research

### Research Questions

1. **How should the frontend consume version data from backend?**
   - Option A: REST API endpoint returning JSON array
   - Option B: Embed data in page template during server render
   - Option C: Serve as static JavaScript file generated at startup

2. **What format should the API response use?**
   - Simple string array vs enriched objects with metadata
   - Grouping/categorization in response or client-side

3. **How to handle file reload without restart?**
   - Watch file for changes
   - Admin endpoint to trigger reload
   - Accept reload on next request (lazy)

4. **Should we enhance java_versions.txt format?**
   - Keep as simple newline-delimited list
   - Add metadata (EOL dates, license status) to file
   - Keep simple, derive metadata from version string

### Research Findings

*To be documented in research.md*

## Phase 1: Design & Contracts

### API Contract

**Endpoint**: `GET /api/versions`
**Response**: JSON array of version strings
**Example**:
```json
["1.0", "1.0.1", "1.0.2", ..., "25", "25.0.1", "25.0.2"]
```

### Data Model

**VersionListService**:
- Responsibilities: Load java_versions.txt, cache in memory, serve via API
- Thread safety: Read-only after load, synchronized reload
- Validation: Non-empty lines, trim whitespace, reject malformed

### Integration Points

1. **JavaVersionResource** - add GET endpoint for /api/versions
2. **Frontend (index.html)** - replace hardcoded array with fetch() call
3. **VersionListService** - new service to manage version list lifecycle

*Detailed design in data-model.md and contracts/*

---

**Next Command**: `/iikit-06-tasks` to generate implementation task breakdown
